# ============================================================
# ans.ps1 - Remote Windows Cluster Info Collector
# Reads hostnames from a CSV, connects to each via WinRM,
# collects cluster name, SQL log path, and SQL version,
# then saves results back to a CSV.
# ============================================================

# --- Configuration ---
$InputCsv  = ".\machines.csv"          # Input CSV (must have a "Hostname" column)
$OutputCsv = ".\machines_results.csv"  # Output CSV path
$HostnameColumn = "Hostname"           # Column name in your CSV that holds machine names

# --- Prompt for credentials once (used for all machines) ---
$credUser = Read-Host "Enter username (e.g. DOMAIN\username)"
$credPass = Read-Host "Enter password" -AsSecureString
$Credential = New-Object System.Management.Automation.PSCredential($credUser, $credPass)

# --- Load the CSV ---
$machines = Import-Csv -Path $InputCsv

# --- Session options (no admin rights needed, skips certificate trust checks) ---
$sessionOption = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck

# --- Results array ---
$results = @()

foreach ($machine in $machines) {
    $hostname = $machine.$HostnameColumn

    Write-Host "`nConnecting to $hostname ..." -ForegroundColor Cyan

    try {
        $result = Invoke-Command -ComputerName $hostname -Credential $Credential -Authentication Negotiate -SessionOption $sessionOption -ErrorAction Stop -ScriptBlock {

            # 1. Get Windows Failover Cluster Name
            $clusterName = $null
            try {
                # Try loading FailoverClusters module (requires RSAT on remote machine)
                Import-Module FailoverClusters -ErrorAction Stop
                $clusterName = (Get-Cluster -ErrorAction Stop).Name
            } catch {
                # Fallback 1: Read cluster name from registry (works without RSAT)
                try {
                    $clusterName = (Get-ItemProperty -Path "HKLM:\Cluster" -Name "ClusterName" -ErrorAction Stop).ClusterName
                } catch {
                    # Fallback 2: Read from environment/WMI
                    try {
                        $clusterName = (Get-WmiObject -Namespace root\MSCluster -Class MSCluster_Cluster -ErrorAction Stop).Name
                    } catch {
                        $clusterName = "N/A (FailoverClusters module not installed)"
                    }
                }
            }

            # 2. Get SQL Server Error Log Path using the cluster name as the instance
            #    Falls back to local machine name if cluster name not found
            $sqlInstance = if ($clusterName -and $clusterName -notlike "N/A*") { $clusterName } else { $env:COMPUTERNAME }
            $logPath = $null
            try {
                $logRow = Invoke-Sqlcmd -ServerInstance $sqlInstance `
                                        -Database master `
                                        -Query "EXEC xp_readerrorlog 0,1,N'Logging SQL Server messages in file';" `
                                        -ErrorAction Stop |
                          Where-Object { $_.Text -like "*Logging*" } |
                          Select-Object -First 1
                $logPath = if ($logRow) { $logRow.Text } else { "N/A" }
            } catch {
                $logPath = "ERROR: $_"
            }

            # 3. Get SQL Server Version
            $version = $null
            try {
                $versionRow = Invoke-Sqlcmd -ServerInstance $sqlInstance `
                                            -Database master `
                                            -Query "SELECT @@VERSION AS Version;" `
                                            -ErrorAction Stop
                $version = if ($versionRow) { $versionRow.Version } else { "N/A" }
            } catch {
                # Fallback: try sqlcmd.exe CLI
                try {
                    $version = (sqlcmd -S $sqlInstance -d master -E -Q "SELECT @@VERSION" 2>&1) -join " "
                } catch {
                    $version = "ERROR: $_"
                }
            }

            # Return collected info
            [PSCustomObject]@{
                ClusterName = $clusterName
                LogPath     = $logPath
                Version     = $version
            }
        }

        Write-Host "  OK" -ForegroundColor Green
        $results += [PSCustomObject]@{
            Hostname    = $hostname
            ClusterName = $result.ClusterName
            LogPath     = $result.LogPath
            Version     = $result.Version
            Status      = "OK"
        }

    } catch {
        Write-Host "  FAILED: $_" -ForegroundColor Red
        $results += [PSCustomObject]@{
            Hostname    = $hostname
            ClusterName = "N/A"
            LogPath     = "N/A"
            Version     = "N/A"
            Status      = "ERROR: $($_.Exception.Message)"
        }
    }
}

# --- Export results to CSV ---
$results | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
Write-Host "`nDone! Results saved to $OutputCsv" -ForegroundColor Green
